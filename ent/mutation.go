// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"zotregistry.io/zot/ent/element"
	"zotregistry.io/zot/ent/predicate"
	"zotregistry.io/zot/ent/resource"
	"zotregistry.io/zot/ent/statement"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeElement   = "Element"
	TypeResource  = "Resource"
	TypeStatement = "Statement"
)

// ElementMutation represents an operation that mutates the Element nodes in the graph.
type ElementMutation struct {
	config
	op                Op
	typ               string
	id                *int
	resourceType      *string
	locatorType       *string
	clearedFields     map[string]struct{}
	statements        map[int]struct{}
	removedstatements map[int]struct{}
	clearedstatements bool
	resources         map[int]struct{}
	removedresources  map[int]struct{}
	clearedresources  bool
	locations         map[int]struct{}
	removedlocations  map[int]struct{}
	clearedlocations  bool
	done              bool
	oldValue          func(context.Context) (*Element, error)
	predicates        []predicate.Element
}

var _ ent.Mutation = (*ElementMutation)(nil)

// elementOption allows management of the mutation configuration using functional options.
type elementOption func(*ElementMutation)

// newElementMutation creates new mutation for the Element entity.
func newElementMutation(c config, op Op, opts ...elementOption) *ElementMutation {
	m := &ElementMutation{
		config:        c,
		op:            op,
		typ:           TypeElement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withElementID sets the ID field of the mutation.
func withElementID(id int) elementOption {
	return func(m *ElementMutation) {
		var (
			err   error
			once  sync.Once
			value *Element
		)
		m.oldValue = func(ctx context.Context) (*Element, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Element.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withElement sets the old Element of the mutation.
func withElement(node *Element) elementOption {
	return func(m *ElementMutation) {
		m.oldValue = func(context.Context) (*Element, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ElementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ElementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ElementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ElementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Element.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceType sets the "resourceType" field.
func (m *ElementMutation) SetResourceType(s string) {
	m.resourceType = &s
}

// ResourceType returns the value of the "resourceType" field in the mutation.
func (m *ElementMutation) ResourceType() (r string, exists bool) {
	v := m.resourceType
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resourceType" field's value of the Element entity.
// If the Element object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElementMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resourceType" field.
func (m *ElementMutation) ResetResourceType() {
	m.resourceType = nil
}

// SetLocatorType sets the "locatorType" field.
func (m *ElementMutation) SetLocatorType(s string) {
	m.locatorType = &s
}

// LocatorType returns the value of the "locatorType" field in the mutation.
func (m *ElementMutation) LocatorType() (r string, exists bool) {
	v := m.locatorType
	if v == nil {
		return
	}
	return *v, true
}

// OldLocatorType returns the old "locatorType" field's value of the Element entity.
// If the Element object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElementMutation) OldLocatorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocatorType: %w", err)
	}
	return oldValue.LocatorType, nil
}

// ResetLocatorType resets all changes to the "locatorType" field.
func (m *ElementMutation) ResetLocatorType() {
	m.locatorType = nil
}

// AddStatementIDs adds the "statements" edge to the Statement entity by ids.
func (m *ElementMutation) AddStatementIDs(ids ...int) {
	if m.statements == nil {
		m.statements = make(map[int]struct{})
	}
	for i := range ids {
		m.statements[ids[i]] = struct{}{}
	}
}

// ClearStatements clears the "statements" edge to the Statement entity.
func (m *ElementMutation) ClearStatements() {
	m.clearedstatements = true
}

// StatementsCleared reports if the "statements" edge to the Statement entity was cleared.
func (m *ElementMutation) StatementsCleared() bool {
	return m.clearedstatements
}

// RemoveStatementIDs removes the "statements" edge to the Statement entity by IDs.
func (m *ElementMutation) RemoveStatementIDs(ids ...int) {
	if m.removedstatements == nil {
		m.removedstatements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.statements, ids[i])
		m.removedstatements[ids[i]] = struct{}{}
	}
}

// RemovedStatements returns the removed IDs of the "statements" edge to the Statement entity.
func (m *ElementMutation) RemovedStatementsIDs() (ids []int) {
	for id := range m.removedstatements {
		ids = append(ids, id)
	}
	return
}

// StatementsIDs returns the "statements" edge IDs in the mutation.
func (m *ElementMutation) StatementsIDs() (ids []int) {
	for id := range m.statements {
		ids = append(ids, id)
	}
	return
}

// ResetStatements resets all changes to the "statements" edge.
func (m *ElementMutation) ResetStatements() {
	m.statements = nil
	m.clearedstatements = false
	m.removedstatements = nil
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *ElementMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *ElementMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *ElementMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *ElementMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *ElementMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ElementMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ElementMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddLocationIDs adds the "locations" edge to the Resource entity by ids.
func (m *ElementMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Resource entity.
func (m *ElementMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Resource entity was cleared.
func (m *ElementMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Resource entity by IDs.
func (m *ElementMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Resource entity.
func (m *ElementMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *ElementMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *ElementMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// Where appends a list predicates to the ElementMutation builder.
func (m *ElementMutation) Where(ps ...predicate.Element) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ElementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ElementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Element, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ElementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ElementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Element).
func (m *ElementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ElementMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.resourceType != nil {
		fields = append(fields, element.FieldResourceType)
	}
	if m.locatorType != nil {
		fields = append(fields, element.FieldLocatorType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ElementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case element.FieldResourceType:
		return m.ResourceType()
	case element.FieldLocatorType:
		return m.LocatorType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ElementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case element.FieldResourceType:
		return m.OldResourceType(ctx)
	case element.FieldLocatorType:
		return m.OldLocatorType(ctx)
	}
	return nil, fmt.Errorf("unknown Element field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case element.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case element.FieldLocatorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocatorType(v)
		return nil
	}
	return fmt.Errorf("unknown Element field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ElementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ElementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Element numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ElementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ElementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ElementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Element nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ElementMutation) ResetField(name string) error {
	switch name {
	case element.FieldResourceType:
		m.ResetResourceType()
		return nil
	case element.FieldLocatorType:
		m.ResetLocatorType()
		return nil
	}
	return fmt.Errorf("unknown Element field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ElementMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.statements != nil {
		edges = append(edges, element.EdgeStatements)
	}
	if m.resources != nil {
		edges = append(edges, element.EdgeResources)
	}
	if m.locations != nil {
		edges = append(edges, element.EdgeLocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ElementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case element.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.statements))
		for id := range m.statements {
			ids = append(ids, id)
		}
		return ids
	case element.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case element.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ElementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstatements != nil {
		edges = append(edges, element.EdgeStatements)
	}
	if m.removedresources != nil {
		edges = append(edges, element.EdgeResources)
	}
	if m.removedlocations != nil {
		edges = append(edges, element.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ElementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case element.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.removedstatements))
		for id := range m.removedstatements {
			ids = append(ids, id)
		}
		return ids
	case element.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case element.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ElementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstatements {
		edges = append(edges, element.EdgeStatements)
	}
	if m.clearedresources {
		edges = append(edges, element.EdgeResources)
	}
	if m.clearedlocations {
		edges = append(edges, element.EdgeLocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ElementMutation) EdgeCleared(name string) bool {
	switch name {
	case element.EdgeStatements:
		return m.clearedstatements
	case element.EdgeResources:
		return m.clearedresources
	case element.EdgeLocations:
		return m.clearedlocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ElementMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Element unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ElementMutation) ResetEdge(name string) error {
	switch name {
	case element.EdgeStatements:
		m.ResetStatements()
		return nil
	case element.EdgeResources:
		m.ResetResources()
		return nil
	case element.EdgeLocations:
		m.ResetLocations()
		return nil
	}
	return fmt.Errorf("unknown Element edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	message         **map[string]interface{}
	clearedFields   map[string]struct{}
	elements        map[int]struct{}
	removedelements map[int]struct{}
	clearedelements bool
	done            bool
	oldValue        func(context.Context) (*Resource, error)
	predicates      []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessage sets the "message" field.
func (m *ResourceMutation) SetMessage(value *map[string]interface{}) {
	m.message = &value
}

// Message returns the value of the "message" field in the mutation.
func (m *ResourceMutation) Message() (r *map[string]interface{}, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldMessage(ctx context.Context) (v *map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ResourceMutation) ResetMessage() {
	m.message = nil
}

// AddElementIDs adds the "elements" edge to the Element entity by ids.
func (m *ResourceMutation) AddElementIDs(ids ...int) {
	if m.elements == nil {
		m.elements = make(map[int]struct{})
	}
	for i := range ids {
		m.elements[ids[i]] = struct{}{}
	}
}

// ClearElements clears the "elements" edge to the Element entity.
func (m *ResourceMutation) ClearElements() {
	m.clearedelements = true
}

// ElementsCleared reports if the "elements" edge to the Element entity was cleared.
func (m *ResourceMutation) ElementsCleared() bool {
	return m.clearedelements
}

// RemoveElementIDs removes the "elements" edge to the Element entity by IDs.
func (m *ResourceMutation) RemoveElementIDs(ids ...int) {
	if m.removedelements == nil {
		m.removedelements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.elements, ids[i])
		m.removedelements[ids[i]] = struct{}{}
	}
}

// RemovedElements returns the removed IDs of the "elements" edge to the Element entity.
func (m *ResourceMutation) RemovedElementsIDs() (ids []int) {
	for id := range m.removedelements {
		ids = append(ids, id)
	}
	return
}

// ElementsIDs returns the "elements" edge IDs in the mutation.
func (m *ResourceMutation) ElementsIDs() (ids []int) {
	for id := range m.elements {
		ids = append(ids, id)
	}
	return
}

// ResetElements resets all changes to the "elements" edge.
func (m *ResourceMutation) ResetElements() {
	m.elements = nil
	m.clearedelements = false
	m.removedelements = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.message != nil {
		fields = append(fields, resource.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldMessage:
		v, ok := value.(*map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.elements != nil {
		edges = append(edges, resource.EdgeElements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeElements:
		ids := make([]ent.Value, 0, len(m.elements))
		for id := range m.elements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedelements != nil {
		edges = append(edges, resource.EdgeElements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeElements:
		ids := make([]ent.Value, 0, len(m.removedelements))
		for id := range m.removedelements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedelements {
		edges = append(edges, resource.EdgeElements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeElements:
		return m.clearedelements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeElements:
		m.ResetElements()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// StatementMutation represents an operation that mutates the Statement nodes in the graph.
type StatementMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	mediaType          *string
	clearedFields      map[string]struct{}
	objects            map[int]struct{}
	removedobjects     map[int]struct{}
	clearedobjects     bool
	_predicates        map[int]struct{}
	removed_predicates map[int]struct{}
	cleared_predicates bool
	subjects           map[int]struct{}
	removedsubjects    map[int]struct{}
	clearedsubjects    bool
	statements         map[int]struct{}
	removedstatements  map[int]struct{}
	clearedstatements  bool
	done               bool
	oldValue           func(context.Context) (*Statement, error)
	predicates         []predicate.Statement
}

var _ ent.Mutation = (*StatementMutation)(nil)

// statementOption allows management of the mutation configuration using functional options.
type statementOption func(*StatementMutation)

// newStatementMutation creates new mutation for the Statement entity.
func newStatementMutation(c config, op Op, opts ...statementOption) *StatementMutation {
	m := &StatementMutation{
		config:        c,
		op:            op,
		typ:           TypeStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatementID sets the ID field of the mutation.
func withStatementID(id int) statementOption {
	return func(m *StatementMutation) {
		var (
			err   error
			once  sync.Once
			value *Statement
		)
		m.oldValue = func(ctx context.Context) (*Statement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatement sets the old Statement of the mutation.
func withStatement(node *Statement) statementOption {
	return func(m *StatementMutation) {
		m.oldValue = func(context.Context) (*Statement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMediaType sets the "mediaType" field.
func (m *StatementMutation) SetMediaType(s string) {
	m.mediaType = &s
}

// MediaType returns the value of the "mediaType" field in the mutation.
func (m *StatementMutation) MediaType() (r string, exists bool) {
	v := m.mediaType
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaType returns the old "mediaType" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldMediaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaType: %w", err)
	}
	return oldValue.MediaType, nil
}

// ResetMediaType resets all changes to the "mediaType" field.
func (m *StatementMutation) ResetMediaType() {
	m.mediaType = nil
}

// AddObjectIDs adds the "objects" edge to the Element entity by ids.
func (m *StatementMutation) AddObjectIDs(ids ...int) {
	if m.objects == nil {
		m.objects = make(map[int]struct{})
	}
	for i := range ids {
		m.objects[ids[i]] = struct{}{}
	}
}

// ClearObjects clears the "objects" edge to the Element entity.
func (m *StatementMutation) ClearObjects() {
	m.clearedobjects = true
}

// ObjectsCleared reports if the "objects" edge to the Element entity was cleared.
func (m *StatementMutation) ObjectsCleared() bool {
	return m.clearedobjects
}

// RemoveObjectIDs removes the "objects" edge to the Element entity by IDs.
func (m *StatementMutation) RemoveObjectIDs(ids ...int) {
	if m.removedobjects == nil {
		m.removedobjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.objects, ids[i])
		m.removedobjects[ids[i]] = struct{}{}
	}
}

// RemovedObjects returns the removed IDs of the "objects" edge to the Element entity.
func (m *StatementMutation) RemovedObjectsIDs() (ids []int) {
	for id := range m.removedobjects {
		ids = append(ids, id)
	}
	return
}

// ObjectsIDs returns the "objects" edge IDs in the mutation.
func (m *StatementMutation) ObjectsIDs() (ids []int) {
	for id := range m.objects {
		ids = append(ids, id)
	}
	return
}

// ResetObjects resets all changes to the "objects" edge.
func (m *StatementMutation) ResetObjects() {
	m.objects = nil
	m.clearedobjects = false
	m.removedobjects = nil
}

// AddPredicateIDs adds the "predicates" edge to the Element entity by ids.
func (m *StatementMutation) AddPredicateIDs(ids ...int) {
	if m._predicates == nil {
		m._predicates = make(map[int]struct{})
	}
	for i := range ids {
		m._predicates[ids[i]] = struct{}{}
	}
}

// ClearPredicates clears the "predicates" edge to the Element entity.
func (m *StatementMutation) ClearPredicates() {
	m.cleared_predicates = true
}

// PredicatesCleared reports if the "predicates" edge to the Element entity was cleared.
func (m *StatementMutation) PredicatesCleared() bool {
	return m.cleared_predicates
}

// RemovePredicateIDs removes the "predicates" edge to the Element entity by IDs.
func (m *StatementMutation) RemovePredicateIDs(ids ...int) {
	if m.removed_predicates == nil {
		m.removed_predicates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._predicates, ids[i])
		m.removed_predicates[ids[i]] = struct{}{}
	}
}

// RemovedPredicates returns the removed IDs of the "predicates" edge to the Element entity.
func (m *StatementMutation) RemovedPredicatesIDs() (ids []int) {
	for id := range m.removed_predicates {
		ids = append(ids, id)
	}
	return
}

// PredicatesIDs returns the "predicates" edge IDs in the mutation.
func (m *StatementMutation) PredicatesIDs() (ids []int) {
	for id := range m._predicates {
		ids = append(ids, id)
	}
	return
}

// ResetPredicates resets all changes to the "predicates" edge.
func (m *StatementMutation) ResetPredicates() {
	m._predicates = nil
	m.cleared_predicates = false
	m.removed_predicates = nil
}

// AddSubjectIDs adds the "subjects" edge to the Element entity by ids.
func (m *StatementMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Element entity.
func (m *StatementMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Element entity was cleared.
func (m *StatementMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Element entity by IDs.
func (m *StatementMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Element entity.
func (m *StatementMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *StatementMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *StatementMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// AddStatementIDs adds the "statements" edge to the Element entity by ids.
func (m *StatementMutation) AddStatementIDs(ids ...int) {
	if m.statements == nil {
		m.statements = make(map[int]struct{})
	}
	for i := range ids {
		m.statements[ids[i]] = struct{}{}
	}
}

// ClearStatements clears the "statements" edge to the Element entity.
func (m *StatementMutation) ClearStatements() {
	m.clearedstatements = true
}

// StatementsCleared reports if the "statements" edge to the Element entity was cleared.
func (m *StatementMutation) StatementsCleared() bool {
	return m.clearedstatements
}

// RemoveStatementIDs removes the "statements" edge to the Element entity by IDs.
func (m *StatementMutation) RemoveStatementIDs(ids ...int) {
	if m.removedstatements == nil {
		m.removedstatements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.statements, ids[i])
		m.removedstatements[ids[i]] = struct{}{}
	}
}

// RemovedStatements returns the removed IDs of the "statements" edge to the Element entity.
func (m *StatementMutation) RemovedStatementsIDs() (ids []int) {
	for id := range m.removedstatements {
		ids = append(ids, id)
	}
	return
}

// StatementsIDs returns the "statements" edge IDs in the mutation.
func (m *StatementMutation) StatementsIDs() (ids []int) {
	for id := range m.statements {
		ids = append(ids, id)
	}
	return
}

// ResetStatements resets all changes to the "statements" edge.
func (m *StatementMutation) ResetStatements() {
	m.statements = nil
	m.clearedstatements = false
	m.removedstatements = nil
}

// Where appends a list predicates to the StatementMutation builder.
func (m *StatementMutation) Where(ps ...predicate.Statement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Statement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Statement).
func (m *StatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatementMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.mediaType != nil {
		fields = append(fields, statement.FieldMediaType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldMediaType:
		return m.MediaType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statement.FieldMediaType:
		return m.OldMediaType(ctx)
	}
	return nil, fmt.Errorf("unknown Statement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statement.FieldMediaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaType(v)
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatementMutation) ResetField(name string) error {
	switch name {
	case statement.FieldMediaType:
		m.ResetMediaType()
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.objects != nil {
		edges = append(edges, statement.EdgeObjects)
	}
	if m._predicates != nil {
		edges = append(edges, statement.EdgePredicates)
	}
	if m.subjects != nil {
		edges = append(edges, statement.EdgeSubjects)
	}
	if m.statements != nil {
		edges = append(edges, statement.EdgeStatements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statement.EdgeObjects:
		ids := make([]ent.Value, 0, len(m.objects))
		for id := range m.objects {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgePredicates:
		ids := make([]ent.Value, 0, len(m._predicates))
		for id := range m._predicates {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.statements))
		for id := range m.statements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedobjects != nil {
		edges = append(edges, statement.EdgeObjects)
	}
	if m.removed_predicates != nil {
		edges = append(edges, statement.EdgePredicates)
	}
	if m.removedsubjects != nil {
		edges = append(edges, statement.EdgeSubjects)
	}
	if m.removedstatements != nil {
		edges = append(edges, statement.EdgeStatements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statement.EdgeObjects:
		ids := make([]ent.Value, 0, len(m.removedobjects))
		for id := range m.removedobjects {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgePredicates:
		ids := make([]ent.Value, 0, len(m.removed_predicates))
		for id := range m.removed_predicates {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case statement.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.removedstatements))
		for id := range m.removedstatements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedobjects {
		edges = append(edges, statement.EdgeObjects)
	}
	if m.cleared_predicates {
		edges = append(edges, statement.EdgePredicates)
	}
	if m.clearedsubjects {
		edges = append(edges, statement.EdgeSubjects)
	}
	if m.clearedstatements {
		edges = append(edges, statement.EdgeStatements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatementMutation) EdgeCleared(name string) bool {
	switch name {
	case statement.EdgeObjects:
		return m.clearedobjects
	case statement.EdgePredicates:
		return m.cleared_predicates
	case statement.EdgeSubjects:
		return m.clearedsubjects
	case statement.EdgeStatements:
		return m.clearedstatements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatementMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatementMutation) ResetEdge(name string) error {
	switch name {
	case statement.EdgeObjects:
		m.ResetObjects()
		return nil
	case statement.EdgePredicates:
		m.ResetPredicates()
		return nil
	case statement.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case statement.EdgeStatements:
		m.ResetStatements()
		return nil
	}
	return fmt.Errorf("unknown Statement edge %s", name)
}
