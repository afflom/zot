// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"zotregistry.io/zot/ent/object"
	"zotregistry.io/zot/ent/predicate"
	"zotregistry.io/zot/ent/spredicate"
	"zotregistry.io/zot/ent/statement"
	"zotregistry.io/zot/ent/subject"
)

// ObjectWhereInput represents a where input for filtering Object queries.
type ObjectWhereInput struct {
	Predicates []predicate.Object  `json:"-"`
	Not        *ObjectWhereInput   `json:"not,omitempty"`
	Or         []*ObjectWhereInput `json:"or,omitempty"`
	And        []*ObjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "objectType" field predicates.
	ObjectType             *string  `json:"objecttype,omitempty"`
	ObjectTypeNEQ          *string  `json:"objecttypeNEQ,omitempty"`
	ObjectTypeIn           []string `json:"objecttypeIn,omitempty"`
	ObjectTypeNotIn        []string `json:"objecttypeNotIn,omitempty"`
	ObjectTypeGT           *string  `json:"objecttypeGT,omitempty"`
	ObjectTypeGTE          *string  `json:"objecttypeGTE,omitempty"`
	ObjectTypeLT           *string  `json:"objecttypeLT,omitempty"`
	ObjectTypeLTE          *string  `json:"objecttypeLTE,omitempty"`
	ObjectTypeContains     *string  `json:"objecttypeContains,omitempty"`
	ObjectTypeHasPrefix    *string  `json:"objecttypeHasPrefix,omitempty"`
	ObjectTypeHasSuffix    *string  `json:"objecttypeHasSuffix,omitempty"`
	ObjectTypeEqualFold    *string  `json:"objecttypeEqualFold,omitempty"`
	ObjectTypeContainsFold *string  `json:"objecttypeContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ObjectWhereInput) AddPredicates(predicates ...predicate.Object) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ObjectWhereInput filter on the ObjectQuery builder.
func (i *ObjectWhereInput) Filter(q *ObjectQuery) (*ObjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyObjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyObjectWhereInput is returned in case the ObjectWhereInput is empty.
var ErrEmptyObjectWhereInput = errors.New("ent: empty predicate ObjectWhereInput")

// P returns a predicate for filtering objects.
// An error is returned if the input is empty or invalid.
func (i *ObjectWhereInput) P() (predicate.Object, error) {
	var predicates []predicate.Object
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, object.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Object, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, object.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Object, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, object.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, object.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, object.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, object.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, object.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, object.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, object.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, object.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, object.IDLTE(*i.IDLTE))
	}
	if i.ObjectType != nil {
		predicates = append(predicates, object.ObjectTypeEQ(*i.ObjectType))
	}
	if i.ObjectTypeNEQ != nil {
		predicates = append(predicates, object.ObjectTypeNEQ(*i.ObjectTypeNEQ))
	}
	if len(i.ObjectTypeIn) > 0 {
		predicates = append(predicates, object.ObjectTypeIn(i.ObjectTypeIn...))
	}
	if len(i.ObjectTypeNotIn) > 0 {
		predicates = append(predicates, object.ObjectTypeNotIn(i.ObjectTypeNotIn...))
	}
	if i.ObjectTypeGT != nil {
		predicates = append(predicates, object.ObjectTypeGT(*i.ObjectTypeGT))
	}
	if i.ObjectTypeGTE != nil {
		predicates = append(predicates, object.ObjectTypeGTE(*i.ObjectTypeGTE))
	}
	if i.ObjectTypeLT != nil {
		predicates = append(predicates, object.ObjectTypeLT(*i.ObjectTypeLT))
	}
	if i.ObjectTypeLTE != nil {
		predicates = append(predicates, object.ObjectTypeLTE(*i.ObjectTypeLTE))
	}
	if i.ObjectTypeContains != nil {
		predicates = append(predicates, object.ObjectTypeContains(*i.ObjectTypeContains))
	}
	if i.ObjectTypeHasPrefix != nil {
		predicates = append(predicates, object.ObjectTypeHasPrefix(*i.ObjectTypeHasPrefix))
	}
	if i.ObjectTypeHasSuffix != nil {
		predicates = append(predicates, object.ObjectTypeHasSuffix(*i.ObjectTypeHasSuffix))
	}
	if i.ObjectTypeEqualFold != nil {
		predicates = append(predicates, object.ObjectTypeEqualFold(*i.ObjectTypeEqualFold))
	}
	if i.ObjectTypeContainsFold != nil {
		predicates = append(predicates, object.ObjectTypeContainsFold(*i.ObjectTypeContainsFold))
	}

	if i.HasStatement != nil {
		p := object.HasStatement()
		if !*i.HasStatement {
			p = object.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, object.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyObjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return object.And(predicates...), nil
	}
}

// SpredicateWhereInput represents a where input for filtering Spredicate queries.
type SpredicateWhereInput struct {
	Predicates []predicate.Spredicate  `json:"-"`
	Not        *SpredicateWhereInput   `json:"not,omitempty"`
	Or         []*SpredicateWhereInput `json:"or,omitempty"`
	And        []*SpredicateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "predicateType" field predicates.
	PredicateType             *string  `json:"predicatetype,omitempty"`
	PredicateTypeNEQ          *string  `json:"predicatetypeNEQ,omitempty"`
	PredicateTypeIn           []string `json:"predicatetypeIn,omitempty"`
	PredicateTypeNotIn        []string `json:"predicatetypeNotIn,omitempty"`
	PredicateTypeGT           *string  `json:"predicatetypeGT,omitempty"`
	PredicateTypeGTE          *string  `json:"predicatetypeGTE,omitempty"`
	PredicateTypeLT           *string  `json:"predicatetypeLT,omitempty"`
	PredicateTypeLTE          *string  `json:"predicatetypeLTE,omitempty"`
	PredicateTypeContains     *string  `json:"predicatetypeContains,omitempty"`
	PredicateTypeHasPrefix    *string  `json:"predicatetypeHasPrefix,omitempty"`
	PredicateTypeHasSuffix    *string  `json:"predicatetypeHasSuffix,omitempty"`
	PredicateTypeEqualFold    *string  `json:"predicatetypeEqualFold,omitempty"`
	PredicateTypeContainsFold *string  `json:"predicatetypeContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SpredicateWhereInput) AddPredicates(predicates ...predicate.Spredicate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SpredicateWhereInput filter on the SpredicateQuery builder.
func (i *SpredicateWhereInput) Filter(q *SpredicateQuery) (*SpredicateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySpredicateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySpredicateWhereInput is returned in case the SpredicateWhereInput is empty.
var ErrEmptySpredicateWhereInput = errors.New("ent: empty predicate SpredicateWhereInput")

// P returns a predicate for filtering spredicates.
// An error is returned if the input is empty or invalid.
func (i *SpredicateWhereInput) P() (predicate.Spredicate, error) {
	var predicates []predicate.Spredicate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, spredicate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Spredicate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, spredicate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Spredicate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, spredicate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, spredicate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, spredicate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, spredicate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, spredicate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, spredicate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, spredicate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, spredicate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, spredicate.IDLTE(*i.IDLTE))
	}
	if i.PredicateType != nil {
		predicates = append(predicates, spredicate.PredicateTypeEQ(*i.PredicateType))
	}
	if i.PredicateTypeNEQ != nil {
		predicates = append(predicates, spredicate.PredicateTypeNEQ(*i.PredicateTypeNEQ))
	}
	if len(i.PredicateTypeIn) > 0 {
		predicates = append(predicates, spredicate.PredicateTypeIn(i.PredicateTypeIn...))
	}
	if len(i.PredicateTypeNotIn) > 0 {
		predicates = append(predicates, spredicate.PredicateTypeNotIn(i.PredicateTypeNotIn...))
	}
	if i.PredicateTypeGT != nil {
		predicates = append(predicates, spredicate.PredicateTypeGT(*i.PredicateTypeGT))
	}
	if i.PredicateTypeGTE != nil {
		predicates = append(predicates, spredicate.PredicateTypeGTE(*i.PredicateTypeGTE))
	}
	if i.PredicateTypeLT != nil {
		predicates = append(predicates, spredicate.PredicateTypeLT(*i.PredicateTypeLT))
	}
	if i.PredicateTypeLTE != nil {
		predicates = append(predicates, spredicate.PredicateTypeLTE(*i.PredicateTypeLTE))
	}
	if i.PredicateTypeContains != nil {
		predicates = append(predicates, spredicate.PredicateTypeContains(*i.PredicateTypeContains))
	}
	if i.PredicateTypeHasPrefix != nil {
		predicates = append(predicates, spredicate.PredicateTypeHasPrefix(*i.PredicateTypeHasPrefix))
	}
	if i.PredicateTypeHasSuffix != nil {
		predicates = append(predicates, spredicate.PredicateTypeHasSuffix(*i.PredicateTypeHasSuffix))
	}
	if i.PredicateTypeEqualFold != nil {
		predicates = append(predicates, spredicate.PredicateTypeEqualFold(*i.PredicateTypeEqualFold))
	}
	if i.PredicateTypeContainsFold != nil {
		predicates = append(predicates, spredicate.PredicateTypeContainsFold(*i.PredicateTypeContainsFold))
	}

	if i.HasStatement != nil {
		p := spredicate.HasStatement()
		if !*i.HasStatement {
			p = spredicate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, spredicate.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySpredicateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return spredicate.And(predicates...), nil
	}
}

// StatementWhereInput represents a where input for filtering Statement queries.
type StatementWhereInput struct {
	Predicates []predicate.Statement  `json:"-"`
	Not        *StatementWhereInput   `json:"not,omitempty"`
	Or         []*StatementWhereInput `json:"or,omitempty"`
	And        []*StatementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "namespace" field predicates.
	Namespace             *string  `json:"namespace,omitempty"`
	NamespaceNEQ          *string  `json:"namespaceNEQ,omitempty"`
	NamespaceIn           []string `json:"namespaceIn,omitempty"`
	NamespaceNotIn        []string `json:"namespaceNotIn,omitempty"`
	NamespaceGT           *string  `json:"namespaceGT,omitempty"`
	NamespaceGTE          *string  `json:"namespaceGTE,omitempty"`
	NamespaceLT           *string  `json:"namespaceLT,omitempty"`
	NamespaceLTE          *string  `json:"namespaceLTE,omitempty"`
	NamespaceContains     *string  `json:"namespaceContains,omitempty"`
	NamespaceHasPrefix    *string  `json:"namespaceHasPrefix,omitempty"`
	NamespaceHasSuffix    *string  `json:"namespaceHasSuffix,omitempty"`
	NamespaceEqualFold    *string  `json:"namespaceEqualFold,omitempty"`
	NamespaceContainsFold *string  `json:"namespaceContainsFold,omitempty"`

	// "objects" edge predicates.
	HasObjects     *bool               `json:"hasObjects,omitempty"`
	HasObjectsWith []*ObjectWhereInput `json:"hasObjectsWith,omitempty"`

	// "predicates" edge predicates.
	HasPredicates     *bool                   `json:"hasPredicates,omitempty"`
	HasPredicatesWith []*SpredicateWhereInput `json:"hasPredicatesWith,omitempty"`

	// "subjects" edge predicates.
	HasSubjects     *bool                `json:"hasSubjects,omitempty"`
	HasSubjectsWith []*SubjectWhereInput `json:"hasSubjectsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StatementWhereInput) AddPredicates(predicates ...predicate.Statement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StatementWhereInput filter on the StatementQuery builder.
func (i *StatementWhereInput) Filter(q *StatementQuery) (*StatementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStatementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStatementWhereInput is returned in case the StatementWhereInput is empty.
var ErrEmptyStatementWhereInput = errors.New("ent: empty predicate StatementWhereInput")

// P returns a predicate for filtering statements.
// An error is returned if the input is empty or invalid.
func (i *StatementWhereInput) P() (predicate.Statement, error) {
	var predicates []predicate.Statement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, statement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Statement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, statement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Statement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, statement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, statement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, statement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, statement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, statement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, statement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, statement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, statement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, statement.IDLTE(*i.IDLTE))
	}
	if i.Namespace != nil {
		predicates = append(predicates, statement.NamespaceEQ(*i.Namespace))
	}
	if i.NamespaceNEQ != nil {
		predicates = append(predicates, statement.NamespaceNEQ(*i.NamespaceNEQ))
	}
	if len(i.NamespaceIn) > 0 {
		predicates = append(predicates, statement.NamespaceIn(i.NamespaceIn...))
	}
	if len(i.NamespaceNotIn) > 0 {
		predicates = append(predicates, statement.NamespaceNotIn(i.NamespaceNotIn...))
	}
	if i.NamespaceGT != nil {
		predicates = append(predicates, statement.NamespaceGT(*i.NamespaceGT))
	}
	if i.NamespaceGTE != nil {
		predicates = append(predicates, statement.NamespaceGTE(*i.NamespaceGTE))
	}
	if i.NamespaceLT != nil {
		predicates = append(predicates, statement.NamespaceLT(*i.NamespaceLT))
	}
	if i.NamespaceLTE != nil {
		predicates = append(predicates, statement.NamespaceLTE(*i.NamespaceLTE))
	}
	if i.NamespaceContains != nil {
		predicates = append(predicates, statement.NamespaceContains(*i.NamespaceContains))
	}
	if i.NamespaceHasPrefix != nil {
		predicates = append(predicates, statement.NamespaceHasPrefix(*i.NamespaceHasPrefix))
	}
	if i.NamespaceHasSuffix != nil {
		predicates = append(predicates, statement.NamespaceHasSuffix(*i.NamespaceHasSuffix))
	}
	if i.NamespaceEqualFold != nil {
		predicates = append(predicates, statement.NamespaceEqualFold(*i.NamespaceEqualFold))
	}
	if i.NamespaceContainsFold != nil {
		predicates = append(predicates, statement.NamespaceContainsFold(*i.NamespaceContainsFold))
	}

	if i.HasObjects != nil {
		p := statement.HasObjects()
		if !*i.HasObjects {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasObjectsWith) > 0 {
		with := make([]predicate.Object, 0, len(i.HasObjectsWith))
		for _, w := range i.HasObjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasObjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasObjectsWith(with...))
	}
	if i.HasPredicates != nil {
		p := statement.HasPredicates()
		if !*i.HasPredicates {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPredicatesWith) > 0 {
		with := make([]predicate.Spredicate, 0, len(i.HasPredicatesWith))
		for _, w := range i.HasPredicatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPredicatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasPredicatesWith(with...))
	}
	if i.HasSubjects != nil {
		p := statement.HasSubjects()
		if !*i.HasSubjects {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectsWith) > 0 {
		with := make([]predicate.Subject, 0, len(i.HasSubjectsWith))
		for _, w := range i.HasSubjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasSubjectsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStatementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return statement.And(predicates...), nil
	}
}

// SubjectWhereInput represents a where input for filtering Subject queries.
type SubjectWhereInput struct {
	Predicates []predicate.Subject  `json:"-"`
	Not        *SubjectWhereInput   `json:"not,omitempty"`
	Or         []*SubjectWhereInput `json:"or,omitempty"`
	And        []*SubjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "subjectType" field predicates.
	SubjectType             *string  `json:"subjecttype,omitempty"`
	SubjectTypeNEQ          *string  `json:"subjecttypeNEQ,omitempty"`
	SubjectTypeIn           []string `json:"subjecttypeIn,omitempty"`
	SubjectTypeNotIn        []string `json:"subjecttypeNotIn,omitempty"`
	SubjectTypeGT           *string  `json:"subjecttypeGT,omitempty"`
	SubjectTypeGTE          *string  `json:"subjecttypeGTE,omitempty"`
	SubjectTypeLT           *string  `json:"subjecttypeLT,omitempty"`
	SubjectTypeLTE          *string  `json:"subjecttypeLTE,omitempty"`
	SubjectTypeContains     *string  `json:"subjecttypeContains,omitempty"`
	SubjectTypeHasPrefix    *string  `json:"subjecttypeHasPrefix,omitempty"`
	SubjectTypeHasSuffix    *string  `json:"subjecttypeHasSuffix,omitempty"`
	SubjectTypeEqualFold    *string  `json:"subjecttypeEqualFold,omitempty"`
	SubjectTypeContainsFold *string  `json:"subjecttypeContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubjectWhereInput) AddPredicates(predicates ...predicate.Subject) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubjectWhereInput filter on the SubjectQuery builder.
func (i *SubjectWhereInput) Filter(q *SubjectQuery) (*SubjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubjectWhereInput is returned in case the SubjectWhereInput is empty.
var ErrEmptySubjectWhereInput = errors.New("ent: empty predicate SubjectWhereInput")

// P returns a predicate for filtering subjects.
// An error is returned if the input is empty or invalid.
func (i *SubjectWhereInput) P() (predicate.Subject, error) {
	var predicates []predicate.Subject
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subject.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subject, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subject.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subject, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subject.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subject.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subject.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subject.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subject.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subject.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subject.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subject.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subject.IDLTE(*i.IDLTE))
	}
	if i.SubjectType != nil {
		predicates = append(predicates, subject.SubjectTypeEQ(*i.SubjectType))
	}
	if i.SubjectTypeNEQ != nil {
		predicates = append(predicates, subject.SubjectTypeNEQ(*i.SubjectTypeNEQ))
	}
	if len(i.SubjectTypeIn) > 0 {
		predicates = append(predicates, subject.SubjectTypeIn(i.SubjectTypeIn...))
	}
	if len(i.SubjectTypeNotIn) > 0 {
		predicates = append(predicates, subject.SubjectTypeNotIn(i.SubjectTypeNotIn...))
	}
	if i.SubjectTypeGT != nil {
		predicates = append(predicates, subject.SubjectTypeGT(*i.SubjectTypeGT))
	}
	if i.SubjectTypeGTE != nil {
		predicates = append(predicates, subject.SubjectTypeGTE(*i.SubjectTypeGTE))
	}
	if i.SubjectTypeLT != nil {
		predicates = append(predicates, subject.SubjectTypeLT(*i.SubjectTypeLT))
	}
	if i.SubjectTypeLTE != nil {
		predicates = append(predicates, subject.SubjectTypeLTE(*i.SubjectTypeLTE))
	}
	if i.SubjectTypeContains != nil {
		predicates = append(predicates, subject.SubjectTypeContains(*i.SubjectTypeContains))
	}
	if i.SubjectTypeHasPrefix != nil {
		predicates = append(predicates, subject.SubjectTypeHasPrefix(*i.SubjectTypeHasPrefix))
	}
	if i.SubjectTypeHasSuffix != nil {
		predicates = append(predicates, subject.SubjectTypeHasSuffix(*i.SubjectTypeHasSuffix))
	}
	if i.SubjectTypeEqualFold != nil {
		predicates = append(predicates, subject.SubjectTypeEqualFold(*i.SubjectTypeEqualFold))
	}
	if i.SubjectTypeContainsFold != nil {
		predicates = append(predicates, subject.SubjectTypeContainsFold(*i.SubjectTypeContainsFold))
	}

	if i.HasStatement != nil {
		p := subject.HasStatement()
		if !*i.HasStatement {
			p = subject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subject.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subject.And(predicates...), nil
	}
}
